<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content=" | The personal web site of Denis Papathanasiou">
    <meta name="author" content="Denis Papathanasiou">
    <title>Re-creating Mailinator in Python</title>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css">
    <link href="../css/my-blog.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>

<body>

  <a id="menu-toggle" href="#" class="btn btn-dark btn-lg toggle"><i class="fa fa-bars"></i></a>
  <nav id="sidebar-wrapper">
    <ul class="sidebar-nav">
      <a id="menu-close" href="#" class="btn btn-light btn-lg pull-right toggle"><i class="fa fa-times"></i></a>
      <li class="sidebar-brand"><a href="../" onclick="$('#menu-close').click();" >Denis Papathanasiou</a></li>
      <li class="sidebar-brand"><a href="../aikido.html" onclick="$('#menu-close').click();" >aikido</a></li>
      <li class="sidebar-brand"><a href="../hardware.html" onclick="$('#menu-close').click();" >hardware</a></li>
      <li class="sidebar-brand"><a href="../programming.html" onclick="$('#menu-close').click();" >programming</a></li>
      <li class="sidebar-brand"><a href="../random.html" onclick="$('#menu-close').click();" >random</a></li>
      <li class="sidebar-brand"><a href="../technology.html" onclick="$('#menu-close').click();" >technology</a></li>
      <li class="sidebar-brand"><a href="../#contacts" onclick="$('#menu-close').click();" >contact</a></li>
    </ul>
  </nav>


  <header class="intro-header" style="background-image: url('/img/source-code-bg.jpg')"> <!-- source: https://pixabay.com/en/source-code-code-programming-c-583537/ -->
    <div class="container">
      <div class="row">
	<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
	  <div class="site-heading" style="color:#00ff00">
	    <h1>Re-creating Mailinator in Python</h1>
	    <hr class="small">
	    <h2 class="subheading"></h2>
	    <p class="post-meta"><i class="fa fa-calendar"></i> November 11, 2011</p>

	  </div>
	</div>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<b>Update:</b> February 21, 2012

<p>
I've extended this concept into a framework for creating an intelligent email-based agent server, whereby email sent to designated inboxes get dynamic, or custom replies.
</p>

<p>
It's the same logic used by the <a href='http://teamwork.io/' target='_blank'>TeamWork.io</a> web service and I've decided to open source it on github: <a href='https://github.com/dpapathanasiou/intelligent-smtp-responder' target="_blank">https://github.com/dpapathanasiou/intelligent-smtp-responder</a>
</p>
<hr />

<a href="http://paultyma.blogspot.com/" target="_blank">Paul Tyma</a>, the creator of <a href="http://mailinator.com/" target="_blank">Mailinator</a>, once <a href="http://mailinator.blogspot.com/2007/01/architecture-of-mailinator.html" target="_blank">wrote about its architecture</a>. He said that after starting with <a href="http://www.sendmail.org/" target="_blank">sendmail</a>, he found it necessary to write his own SMTP server from scratch.

While he never released the Java source code of his server, I wanted to see if I could re-create it using Python, since I also wanted to understand how <a href="http://en.wikipedia.org/wiki/State_machine" target="_blank">state machines</a> work in that language.

<h3>The Basic Server</h3>

To start, I needed some code that would listen on a specific port, and read and respond to clients.

Python's <a href="http://docs.python.org/library/socketserver.html" target="_blank">SocketServer</a> module makes this simple.

Here, in a few lines, is a multi-threaded TCP server that listens on port 8888 of the local machine and echoes back what a connected client sends to it:

<pre>
#!/usr/bin/python
</pre><pre>
import SocketServer
</pre><pre>
cr_lf = "\r\n"
</pre><pre>
class SMTPRequestHandler (SocketServer.StreamRequestHandler):
    def handle (self):
        try:
            while 1:
                client_msg = self.rfile.readline()
                self.wfile.write(client_msg.rstrip()+cr_lf) # a simple echo
        except Exception, e:
            print e
</pre><pre>
# server hostname and port to listen on
server_config = ('localhost', 8888) 
</pre><pre>
if __name__ == '__main__':
    tcpserver = SocketServer.ThreadingTCPServer(server_config, SMTPRequestHandler) 
    tcpserver.serve_forever() 
</pre>

Start it from a command line prompt (if the port number you choose is less than 1025, then you need to do this as root):

<pre>
$ python server.py
</pre>

And test it using telnet:

<pre>
$ telnet localhost 8888
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
This is an echo
This is an echo
Ok, I get it
Ok, I get it
What next?
What next?
</pre>

<h3>Handling SMTP</h3>

Now I needed to be able to understand and reply to SMTP requests. The <a href="http://tools.ietf.org/html/rfc2821" target="_blank">protocol</a> is fairly simple, with only <a href="http://www.samlogic.net/articles/smtp-commands-reference.htm" target="_blank">a handful of commands</a>. 

Each command consists of four letters, which appear at the start of the stream sent by the client, and terminated with "\r\n".

<img src="http://i.imgur.com/CkrzJ.png" alt="SMTP commands" />

Tyma did not, however, implement the full list of SMTP commands, since RSET (Reset), VRFY (Verify), NOOP (No operation), and others are used by spammers to abuse or even take over a server, and are rarely required by legitimate email clients.

The server needs to be able to handle the <a href="http://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol#SMTP_transport_example" target="_blank">basic interaction</a>, so HELO (Hello) / EHLO (Extended Hello), MAIL (Mail from), RCPT TO (Recipient To), and DATA all need to be supported.

At first glance, it's tempting to try to implement it like this:

<pre>
class SMTPRequestHandler (SocketServer.StreamRequestHandler):
    def handle (self):
        try:
            data = {}
            while 1:
                client_msg = self.rfile.readline()
                if client_msg.startswith('MAIL FROM:'):
                    data['sender'] = get_email_address(client_msg)
                elif client_msg.startswith('RCPT TO:'):
                    data['recipient'] = = get_email_address(client_msg)
</pre><pre>
                ...
</pre><pre>
                elif client_msg.startswith('QUIT'):
                    break
        except Exception, e:
            print e
</pre>

Where <code>get_email_address()</code> is defined as, for example, something like this:

<pre>
def get_email_address (s):
    """Parse out the first email address found in the string and return it"""
    for token in s.split():
        if token.find('@') > -1:
            # token will be in the form:
            # 'FROM:<bob @example.org>' or 'TO:<alice @example.org>'
            # and with or without the <>
            for email_part in token.split(':'): 
                if email_part.find('@') > -1:
                    return email_part.strip('<>')
</alice></bob></pre>

But this gets messy in a hurry. While some commands fit within the neat single-line <code>/^CMND rest of data\r\n/</code> pattern, others do not.

RCPT, for example, can be repeated multiple times, and once DATA is seen, every subsequent line must be collected until the final <code>/^\.$/</code> appears.

<h3>State Machines to the rescue</h3>

A state machine provides a much better way of handling SMTP requests. In his <a href="http://www.ibm.com/developerworks/library/l-python-state/index.html" target="_blank">excellent article</a>, David Mertz defines a state machine as:

<blockquote>a directed graph, consisting of a set of nodes and a corresponding set of transition functions. The machine "runs" by responding to a series of events. Each event is in the domain of the transition function belonging to the "current" node, where the function's range is a subset of the nodes. The function returns the "next" (perhaps the same) node. At least one of these nodes must be an end-state. When an end-state is reached, the machine stops.</blockquote>

And that corresponds exactly to what happens when a client interacts with an SMTP server:

<img src="http://i.imgur.com/Cm85Y.png" alt="SMTP State Diagram" />

<h3>Brass Tacks</h3>

Creating a state machine in Python is simple, since Python allows you to pass functions as higher-order objects. The <a href="http://www.ibm.com/developerworks/library/l-python-state/index.html#N101B7">statemachine.py</a> implementation in Mertz's article was done in just a few lines of code.

To handle each SMTP node, I defined a series of functions, one for each server response or command.

Here are the function prototypes, where the <code>cargo</code> parameter is a tuple, containing both the stream from/to requests are read and responses written, and a dict of data collected from the request:

<pre>
def greeting (cargo):
def helo (cargo):
def mail (cargo):
def rcpt (cargo):
def data (cargo):
def process (cargo):
</pre>

The state machine is defined within the SMTPRequestHandler class like this:

<pre>
class SMTPRequestHandler (SocketServer.StreamRequestHandler):
    def handle (self):
        try:
            m = StateMachine()
            m.add_state('greeting', greeting)
            m.add_state('helo', helo)
            m.add_state('mail', mail)
            m.add_state('rcpt', rcpt)
            m.add_state('data', data)
            m.add_state('process', process)
            m.add_state('done', None, end_state=1)
            m.set_start('greeting')
</pre><pre>
            m.run((self, {}))
        except Exception, e:
            print e
</pre>

So that each function knows how to recognize its assigned command, I defined and compiled these regular expressions. These are created as globals, since it's more efficient to initiate them once, and have each subsequent method call use the already-existing version.

<pre>
import re
helo_pattern = re.compile('^HELO', re.IGNORECASE)
ehlo_pattern = re.compile('^EHLO', re.IGNORECASE)
mail_pattern = re.compile('^MAIL', re.IGNORECASE)
rcpt_pattern = re.compile('^RCPT', re.IGNORECASE)
data_pattern = re.compile('^DATA', re.IGNORECASE)
end_pattern = re.compile('^.$')
</pre>

The <code>greeting()</code> function, which begins the interaction with the client, sends a simple message and passes control to the <code>helo()</code> function. It looks like this:

<pre>
def greeting (cargo):
    stream = cargo[0]
    stream.wfile.write('220 localhost SMTP'+cr_lf)
    return ('helo', cargo)
</pre>

Later in the sequence, the <code>mail()</code> function, which is the first node from which data is collected (in this case, the email address of the sender), is the first to save information in the cargo's dict. It looks like this:

<pre>
def mail (cargo):
    stream = cargo[0]
    client_msg = stream.rfile.readline()
    if mail_pattern.search(client_msg):
        sender = get_email_address(client_msg)
        if sender is None:
            stream.wfile.write(bad_request+cr_lf)
            return ('done', cargo)
        else:
            email_data = cargo[1]
            email_data['sender'] = sender
            return ('rcpt', (stream, email_data))
    else:
        stream.wfile.write(bad_request+cr_lf)
        return ('done', cargo)        
</pre>

Here, if the request is not recognized or invalid, the client sees the <code>bad_request</code> message, and the connection is closed, since control passes to the <code>done</code> end-state.

I followed Tyma's example and defined <code>bad_request</code> as "<code>550 No such user</code>" (which, as he notes, is ironic, since Mailinator accepts email sent to <i>any</i> user).

It also doesn't conform to the protocol, since I'm supposed to give different error messages at different nodes, but since clients are always disconnected after any type of invalid request, it hardly matters what they see in that scenario.

If a client is well-behaved, the final method called is <code>process()</code> which decides what to do with the client's email. The data dict will contain three parameters: 'sender' (the email address of the sender), 'recipients' (a list of email addresses), and 'data' (the contents which followed the DATA command ahead of the final '.').

<pre>
def process (cargo):
    email_data = cargo[1]
    # do something with the email_data dict here
</pre><pre>
    return ('done', cargo)
</pre>

Basically, this is where the data can be saved to disk/db (so that it can be served by a web browser later, e.g.), MIME-parsed (to remove attachments, etc.), or just trashed (if you have reason to believe the sender is a spambot or zombie network, e.g.).

Tyma describes various measures for dealing with attacks from spambots and zombies which I haven't implemented here, but would be relatively easy to add to both the <code>data()</code> and <code>process()</code> functions.

Obtaining the ip address of the client is done using the <code>stream.client_address[0]</code> attribute.

<p>&nbsp;</p>


        <hr>
      </div>
    </div>
  </div>

  <hr>

  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
	<a name="contacts"></a>
	<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
	  <ul class="list-inline text-center">
	    <li>
	      <a href="mailto:denis@papathanasiou.org">
		<span class="fa-stack fa-lg">
		  <i class="fa fa-circle fa-stack-2x"></i>
		  <i class="fa fa-envelope-o fa-stack-1x fa-inverse"></i>
		</span>
	      </a>
	    </li>
	    <li>
	      <a href="https://github.com/dpapathanasiou">
		<span class="fa-stack fa-lg">
		  <i class="fa fa-circle fa-stack-2x"></i>
		  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
		</span>
	      </a>
	    </li>
	  </ul>
	</div>
      </div>
      <div class="row">
	<a name="license"></a>
	<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
	  <p class="copyright text-muted">
	    <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a> &nbsp;
	    This site's content is licensed under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons (BY-NC-SA 4.0)</a>
	  </p>
	</div>
      </div>
    </div>
  </footer>

  <script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
  <script src="../js/my-blog.min.js"></script>
  
</body>
</html>


